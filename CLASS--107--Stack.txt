Stack:
It was introduced in JDK1.0 version, it is a Legacy Collection and it is a child class to Vector class. It able to arrange all the elements as per "Last In First Out"
[LIFO] alg.

Constructor:
public Stack()
--> It will create an empty Stack object.
EX: Stack s=new Stack();

Methods:
===========
public void push(Object obj)
--> It will add the specified element to Stack.
public Object pop()
--> It will remove and return top of the stack.
public Object peek()
--> It will return top of the stack.
public int search(Object obj)
--> It will check whether the specified element is existed or not in the Stack, 
if the specified element is not existed then it will return '-1' value, if the specified element is existed then it will return its position.

01) --package com.RoughWork;

import java.util.Stack;
import java.util.Vector;

public class PraticeClass {
	public static void main(String[] args) {
		Stack<String> s=new Stack<String>();
		s.push("AAA");
		s.push("BBB");
		s.push("CCC");
		s.push("DDD");
		System.out.println(s);
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]

02)--
import java.util.Stack;
public class PraticeClass {
	public static void main(String[] args) {
		Stack<String> s=new Stack<String>();
		s.push("AAA");
		s.push("BBB");
		s.push("CCC");
		s.push("DDD");
		System.out.println(s);
		System.out.println(s.pop());	//It removes and display top of the stack
		System.out.println(s);
		
		System.out.println(s.peek());
		System.out.println(s);
		
		System.out.println(s.search("BBB")); // 2 will return

		System.out.println(s.search("XXX")); //-1 will return
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
DDD
[AAA, BBB, CCC]

CCC
[AAA, BBB, CCC]

2

-1

03)--LinkedList:(374 page--no)
===========================
-->It was introduced in JDK1.2 version.
-->It is not Legacy Collection.
-->It is a direct implementation class to List interface.
-->It is index based.
-->It allows duplicate elements.
-->It follows insertion order.
-->It is not following sorting order.
-->It allows heterogeneous elements.
-->It allows null values in any number.
-->Its internal data structer is "Double Linked List".;
-->It is best choice for frequent insertions and deletions.
-->It is not synchronized Collection.
-->No method is synchronized in LinkedList.
-->It allows more than one thread to access data.
-->It will follow parallel execution.
-->It will decrese execution time.
-->It will improve application performance.
-->It is not giving guarantee for data consistency.
-->It is not threadsafe.

Constructors:
1.public LinkedList()
-->It will create an empty LinkedList object.
EX: LinkedList ll=new LinkedList();

2.public LinkedList(Collection c)
-->It will create LinkedList object with all the elements of the specified Collection object.

3.1) import java.util.LinkedList;
public class PraticeClass {
	public static void main(String[] args) {
		LinkedList<String> ll1=new LinkedList<String>();
		ll1.add("AAA");
		ll1.add("BBB");
		ll1.add("CCC");
		ll1.add("DDD");
		System.out.println(ll1);
		LinkedList<String> ll2=new LinkedList<String>(ll1);
		System.out.println(ll2);
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
[AAA, BBB, CCC, DDD]

3.2)--Methods:
--------------------
1.public void addFirst(Object obj)
-->It will add the specified element as first element to LinkedList.
2.public void addLast(Object obj)
-->It will add the specified element as last element to LinkedList.
3.public Object getFirst()
-->It will return first element from LinkedList.
4.public Object getLast()
-->It will return last element from LinkedList.
5.public void removeFirst()
-->It will remove first element from LinkedList.
6.public void removeLast()
-->It will remove last element from LinkedList.

3.3) public class PraticeClass {
	public static void main(String[] args) {
		LinkedList<String> ll1=new LinkedList<String>();
		ll1.add("AAA");
		ll1.add("BBB");
		ll1.add("CCC");
		ll1.add("DDD");
		System.out.println(ll1);
		ll1.addFirst("XXX");		//XXX will be added as a first element
		ll1.addLast("YYY");		//YYY will be added as a Last Element
		System.out.println(ll1);

		System.out.println(ll1.getFirst()); 
		System.out.println(ll1.getLast());

		ll1.removeFirst();
		ll1.removeFirst();
		System.out.println(ll1);
	
	
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
[XXX, AAA, BBB, CCC, DDD, YYY]

XXX
YYY

[BBB, CCC, DDD, YYY]

3.4)--package com.RoughWork;

import java.util.ArrayList;
import java.util.LinkedList;
class A{
	
}
public class PraticeClass {
	public static void main(String[] args) {
		ArrayList<String> al=new ArrayList<String>();
		al.add("AAA");
		al.add("BBB");
		al.add("CCC");
		al.add("DDD");
		System.out.println(al);
		A a=new A();
		System.out.println(a);
	
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
com.RoughWork.A@15db9742

Cursors / Iterators in Collections:
=============================
1.Create Enumeration object:
To create Enumeration object we have to use the following method from Legacy Collections.
public Enumeration elements()

2.Retrive elements from Enumeration:
a)Check whether more elements are available or not from Current cursor position by using the following method.
public boolean hasMoreElements()
--> It will return true value if atleast next element is existed.
-->It will return false value if no element is existed from current cursor position.
b)If atleast next element is existed then read next element and move cursor to next position by using the following method.
public Object nextElement()

04) public class PraticeClass {
	public static void main(String[] args) {
		Vector<String> v1=new Vector<String>();
		v1.add("AAA");
		v1.add("BBB");
		v1.add("CCC");
		v1.add("DDD");
		System.out.println(v1);
		Enumeration<String> e=v1.elements();
		while(e.hasMoreElements()) {
			System.out.println(e.nextElement());		//Display elements individually
		}
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
AAA
BBB
CCC
DDD





