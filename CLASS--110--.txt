NavigableSet(Page-387)
======================
It was introduced in JAVA6 version, it is a chaild interface to SortedSet interface, it is following all the properties of SortedSet and it has define methods to provide navigations over the elements.
Methods:
1.public Object ceiling(Object obj)
--> It will return lowest element among all the elements which are greater than or equals to the specified element.
2.public Object higher(Object obj)
--> It will return the lowest element among all the elements which are greater than the specified element.
3.public Object floor(Object obj)
-->It will return highest element among all the elements which are less than or equals to the specified element.
4.Trpublic Object lower(Object obj)
-->It will return highest element among all the elements which are less than the specified element.
5.public Object pollFirst()
--> It will remove and return first element from NavigableSet.
6.public Object pollLast()
--> It will remove and return last element from NavigableSet.
7.public NavigableSet descendingSet()
-->It will return all elements in the form of NavigableSet in descending order.

public class PraticeClass {
	public static void main(String[] args) {
		TreeSet<String> ts=new TreeSet<String>();
		ts.add("AAA");
		ts.add("FFF");
		ts.add("BBB");
		ts.add("EEE");
		ts.add("CCC");
		ts.add("DDD");
		System.out.println(ts);		   // Sorting order (Ascending order)
		System.out.println(ts.descendingSet());    //Descending order 
		System.out.println(ts.ceiling("DDD"));	  //Lowest element which has greater than or equal to specified element(DDD)
		System.out.println(ts.higher("DDD"));	  //Lowest element among all the element which are greater than the specified element(EEE)
		System.out.println(ts.floor("DDD"));         //Less than or equal to the specified element(DDD)
		System.out.println(ts.lower("DDD"));      //Highest value among all element which are less than the specified element(CCC)
		ts.pollFirst();			//It will remove and return first element from NavigableSet.
		ts.pollLast();			//It will remove and return last element from NavigableSet.
		System.out.println(ts);
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD, EEE, FFF]
[FFF, EEE, DDD, CCC, BBB, AAA]
DDD
EEE
DDD
CCC
[BBB, CCC, DDD, EEE]


TreeSet:(Page-388)
=================
-->It was introduced in JDK1.2 version.
-->It is not Legacy Collection.
-->It has provided implementation for Collection, Set, SortedSet and navigableSet interfaces.
-->It is not index based.
-->It is not allowing duplicate elements.
-->It is not following insertion order.
-->It follows Sorting order.
-->It allows only homogeneous elements.
-->It will not allow heterogeneous elements, if we are trying to add heterogeneous elements then JVM will rise an exception like java.lang.ClasscastException.
-->It will not allow null values, if we are trying to add any null value then JVM will rise an exception like java.lang.NullPointerException.
-->It able to allow only Comparable objects bydefault, if we are trying to add non comparable objects then JVM will rise an exception like java.lang.ClassCastException.

NOTE: If we are trying to add non comparable objects then we have to use java.util.Comparator.
-->Its internal data structer is "Balanced Tree".
-->It is mainly for frequent search operations.

Constructors:
1.public TreeSet()
-->It can be used to create an Empty TreeSet object.
EX: TreeSet ts=new TreeSet();
2.public TreeSet(Comparator c)
-->It will create an empty TreeSet object with the explicit Sorting mechanism in the form of Comparator
EX: TreeSet ts=new TreeSet(new MyComparator());
3.public TreeSet(SortedSet ts)
-->It will create TreeSet object with all elements of the specified SortedSet.
4.public TreeSet(Collection c)
-->It able to create TreeSet object with all the elements of the specified Collection.

01) public class PraticeClass {
	public static void main(String[] args) {
		TreeSet<String> ts=new TreeSet<String>();
		ts.add("AAA");
		ts.add("BBB");
		ts.add("CCC");
		ts.add("DDD");
		System.out.println(ts);
		TreeSet<String> ts1=new TreeSet<String>(ts);
		System.out.println(ts);
		
		
	}
}

O/P:
-------
[AAA, BBB, CCC, DDD]
[AAA, BBB, CCC, DDD]

02) public class PraticeClass {
	public static void main(String[] args) {
		ArrayList<String> al=new ArrayList<String>();
		al.add("FFF");
		al.add("CCC");
		al.add("AAA");
 		al.add("EEE");
		al.add("BBB");
		al.add("DDD");
		System.out.println(al);
		TreeSet<String> ts=new TreeSet<String>(al);
		System.out.println(ts);
 		
	}
}


O/P:
--------
[FFF, CCC, AAA, EEE, BBB, DDD]
[AAA, BBB, CCC, DDD, EEE, FFF]	//Elements are sorted in Treeset

03)--public class PraticeClass {
	public static void main(String[] args) {
		TreeSet<String> ts=new TreeSet<String>();
		ts.add("AAA");
		ts.add("BBB");
		ts.add("CCC");
		ts.add("DDD");
		System.out.println(ts);
		ts.add("BBB");
		System.out.println(ts);
 		
	}
}

O/P
--------
[AAA, BBB, CCC, DDD]
[AAA, BBB, CCC, DDD]		//Duplicates not allowed

04)--public class PraticeClass {
	public static void main(String[] args) {
		TreeSet ts=new TreeSet();
		ts.add("AAA");
		ts.add("BBB");
		ts.add("CCC");
		ts.add("DDD");
		System.out.println(ts);
		ts.add("BBB");
		System.out.println(ts);
		//Nullpointer exception
 		ts.add(new Integer(10));	//Exception in thread "main" java.lang.ClassCastException:
	}
}

O/P:
------
[AAA, BBB, CCC, DDD]
[AAA, BBB, CCC, DDD]
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
	at java.lang.Integer.compareTo(Unknown Source)
	at java.util.TreeMap.put(Unknown Source)
	at java.util.TreeSet.add(Unknown Source)
	at com.RoughWork.PraticeClass.main(PraticeClass.java:17)

05)--CompareTo Method
======================
When we add elements to the TreeSet object , TreeSet object will arrange all the elements in a particular sorting order withthe following algorithm.
1.TreeSet will construct a Tree[Balanced Tree] on the basis of the elements.
To construct Balanced Tree we have to use the following steps.
a)If the element is first element to the TreeSet object then make that element as "Root Node".
b)If the element is not first element then access compareTo(--) method over the present element by passing previous elements one by one of the balanced Tree right from root node until the present element is located in Tree.
1.If compareTo(-) method returns -ve value then goto left chaild of the present node and access again compareTo(-) method by passing left chaild. If no left chaild is existed then make the present element as left chaild
2.If compareTo(-) method returns +ve value then goto right chails and access again compareTo(-) by passing right as parameter. if no right chaild is existed then make the present element as right chaild.
3.If compareTo(-) method return 0 value then discard the present element and declare that the present element is a duplicate element of the existed element.
2.TreeSet will Retrive all the elements from balanced Tree by following Inorder traversal.
In String class, compareTo(-) method was implemented like below.
str1.compareTo(str2);
1.If str1 come first when compared with str2 as per dictionary order then compareTo() method will return -ve value.
2.If str2 come first when compared with str1 in dictionary order then compareTo() method will return +ve value.
3.If str1 and str2 are same or available at same location in dictionary order then compareTo(-) method will return 0 value.
If we want to add user defined elements like Employee, Student, Customer to TreeSet then we have to use the following steps.
1.Declare an user defined class.
2.Implement java.lang.Comparable iterface in User defined class.
3.Provide implementation for compareTo(-) method in user defined class.
4.In main class , in main() method , create objects for user defined class and add objects to TreeSet object..

01) public class PraticeClass {
	public static void main(String[] args) {
		String str1=new String("abc");
		String str2=new String("def");
		String str3=new String("abc");
		
		System.out.println(str1.compareTo(str2));  -3
		System.out.println(str2.compareTo(str3));   3	
		System.out.println(str3.compareTo(str1));   0
	}
}

O/P:
-------
-3
3
0

02)--CompareTo method
======================
package com.RoughWork;

import java.util.ArrayList;
import java.util.TreeSet;
class Employee implements Comparable<Employee>{
	String eid;
	String ename;
	float esal;
	String eaddr;
	
	public Employee(String eid,String ename,float esal,String eaddr) {
		this.eid=eid;
		this.ename=ename;
		this.esal=esal;
		this.eaddr=eaddr;
		
	}
	
	public String toString() {
		return "["+eid+","+ename+","+esal+","+eaddr+"]";
	}
	
	@Override
	public int compareTo(Employee emp) {
		int val=this.ename.compareTo(emp.ename);
		return val;
	}
	
}
public class PraticeClass {
	public static void main(String[] args) {
		Employee emp1=new Employee("E-111","AAA",5000,"HYD");
		Employee emp2=new Employee("E-222","BBB",6000,"HYD");
		Employee emp3=new Employee("E-333","CCC",7000,"HYD");
		Employee emp4=new Employee("E-444","DDD",8000,"HYD");
		
		TreeSet<Employee> ts=new TreeSet<Employee>();
		ts.add(emp3);
		ts.add(emp1);
		ts.add(emp4);
		ts.add(emp1);
		
		System.out.println(ts);
	}
}

O/P:
-------
[[E-111,AAA,5000.0,HYD], [E-333,CCC,7000.0,HYD], [E-444,DDD,8000.0,HYD]]

Condition
-------------
@Override
	public int compareTo(Employee emp) {
		int val=this.ename.compareTo(emp.ename);
		return -val;
	}

O/P:
------
[[E-444,DDD,8000.0,HYD], [E-333,CCC,7000.0,HYD], [E-111,AAA,5000.0,HYD]]

Explicit sorting
=============
package com.RoughWork;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.TreeSet;
class Mycomprator implements Comparator<StringBuffer>{
	
	@Override
	public int compare(StringBuffer sb1, StringBuffer sb2) {
		int lenght1=sb1.length();
		int length2=sb2.length();
		int val=0;
		if(lenght1<length2) {
			val=-100;
		}
		else if(lenght1>length2) {
			val=100;
		}
		else {
			val=0;
		}
		return val;
	}
	
}
public class PraticeClass {
	public static void main(String[] args) {
		StringBuffer sb1=new StringBuffer("AAA");
		StringBuffer sb2=new StringBuffer("B");
		StringBuffer sb3=new StringBuffer("CCCCC");
		StringBuffer sb4=new StringBuffer("DD");
		StringBuffer sb5=new StringBuffer("EEEE");
		
		Mycomprator mc=new Mycomprator();
		TreeSet<StringBuffer> ts=new TreeSet<StringBuffer>(mc);	//Stringbuffer cannt comparable  
		ts.add(sb1);
		ts.add(sb2);
		ts.add(sb3);
		ts.add(sb4);
		ts.add(sb5);
		
		System.out.println(ts);
	}
}


O/P:
======
[B, DD, AAA, EEEE, CCCCC]		//Length increasing order

public int compare(StringBuffer sb1, StringBuffer sb2) {
		int lenght1=sb1.length();
		int length2=sb2.length();
		int val=0;
		if(lenght1<length2) {
			val=-100;
		}
		else if(lenght1>length2) {
			val=100;
		}
		else {
			val=0;
		}
		return -val;
	}

O/P:
-------
[CCCCC, EEEE, AAA, DD, B]			


Difference between comprator and Comprable


